\begin{frame}{Conclusion}
    \begin{itemize}
        \item Proposed algorithms outperform \textit{LVG} in all cases
        \item \textit{Interval heuristic} works well when targets are many
        \item \textit{Target heuristic} works well when targets are few and $k$ is also small
    \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
  \textit{Shizhe Zhao, David Taniar, Daniel Harabor, "Fast k-Nearest Neighbor On A Navigation Mesh", Proceedings
    of the 11th Annual Symposium on Combinatorial Search (SoCS'2018), colocated with
    IJCAI/ECAI'2018, July 2018 (accepted for publication)}
\end{frame}

\begin{frame}{Future works 1: improve other query processing}
    \begin{itemize}
        \item \small{
            Proposed algorithms can be used to speed up other types of spatial query which need to compute obstacle distance, e.g. \textit{Obstacle Reverse Nearest Neighbor}.
        }
    \end{itemize}
\end{frame}

\begin{frame}{Future works 2: improve \textit{target heuristic}}
    \begin{itemize}
        \item \small {
          \textit{Target heuristic} cost $\approx 80\%$ of total run time in \textit{R-tree} query. 
        }
        \item \small {
            Improve it by combining four queries into one, or using more suitable datastructure.
        }
    \end{itemize}
\end{frame}

\begin{frame}{Future works 3: improve \textit{brute-force Polyanya}}
    \begin{itemize}
        \item \small {
            We notice that \textit{brute-force Polyanya} sometimes outperforms other proposed algorithms in sparse scenario.
        }
        \item \small {
            Instead of considering every target, maybe a smart pruning strategy can make it work in general scenario. 
        }
    \end{itemize}
\end{frame}
